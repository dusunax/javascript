# 📝메모\_231102

## 🔎 현재 학습 플랜

- 10시~11시

- | 순서 | 일정 | 내용         | 관련 서적/강의              |
  | ---- | ---- | ------------ | --------------------------- |
  | 1    | 25   | JS 개념 공부 | 모던 자바스크립트 Deep Dive |

---

## 클래스

### 클래스는 탕후루인가? syntatic sugar

- 자바스크립트: 프로토타입 기반 prototype based 객체지향 언어
- class free. 클래스가 필요 없는 객체지향 프로그래밍 언어
- [ES5] 생성자 함수 + 프로토타입을 통해 상속 구현
- 클래스 기반 객체지향 프로그래밍과 흡사 => 클래스는 근데 함수다

### 클래스 and 생성자 함수

1. new 없이 호출? 클래스 => 오류, 생성자 함수 => 일반 함수
2. extends & super? 클래스 O, 생성자 함수 X
3. 호이스팅? 클래스(발생 않는 것처럼 동작), 생성자 함수 => 함수 선언문은 함수 호이스팅, 함수 표현식은 변수 호이스팅
4. strict mode? 클래스(암묵적으로 지정, 해제 불가능), 생성자는 ㄴㄴ
5. `[[Enumerable]]` = false ? 클래스의 constructor, 프로토타입 메서드, 정적 메서드 => 열거 ㄴㄴ

### 클래스 정의

- 클래스는? 웬만하면 파스칼. 오류는 no
- 표현식으로 할 수도 있기는 하다. means? 일급 객체 (값으로 사용o)
- constructor(생성자), 프로토타입 메서드, 정적 메서드

```tsx
class Person {
  constructor(name) {
    // 생성자
    this.name = name;
  }

  sayHi() {
    // 프로토타입 메서드
    console.log(`Hello, ${this.name}!`);
  }

  static sayHello() {
    // 정적 메서드
    console.log("Say Hello.");
  }
}
```

```tsx
function Person(name) {
  this.name = name;
}

Person.prototype.sayHi = function () {
  console.log(`Hello, ${this.name}!`);
};

Person.sayHello = function () {
  console.log("Say Hello.");
};
```

### 클래스 호이스팅

- 클래스는 함수로 평가된다.
- 함수 선언문처럼 소스코드 평가 과정 (런타임 이전~)에 먼저 평가되어 함수 객체 생성쓰. 그 것은 constructor. 프로토타입과 쌍으로 생성됨. pair
- 클래스는 정의 이전에 참조할 수 읎다 (호이스팅이 발생하지 않는 것처럼 보이지만 그렇지 않다. let, const처럼 호이스팅 된다. TDZ.)
- 모든 식별자는 호이스팅된다. 모든 선언문은 런타임 이전에 먼저 실행

### 인스턴스 생성

- 클래스는 생성자 함수이며, new 연산자와 함께 호출, 인스턴스 생성한다.
- new 연산자 필수! 유일한 존재 이유
- `TypeError: Cannot call a class as a function`

### 메서드

- ECMAScript 사양에 따르면, 인스턴스 프로퍼티는 constructor 내부에서 정의해야 한다.
- 새로운 표준 사양 => 클래스 몸체에서 프로퍼티 정의 (모던 브라우저 ok)

### Constructor

- 이름 변경 x, 인스턴스를 생성하고 초기화하기 위한 특수한 메서드
- 모드 함수 객체가 가지고 있는 prototype 프로퍼티 => 클래스 자신
- constructor는 단순 메서드가 아님 => 함수 객체에 없음
- 생략하면? 암묵적으로 빈 constructor 정의
- 별도의 반환문 x. 명시적으로 반환하면? this 인스턴스가 반환되지 못하고 명시적인 객체 반환 (기본 동작을 훼손한다)

### 프로토타입 메서드

- 생성자 함수: 명시적으로 프로토타입에 메서드 추가
- 클래스: prototype 프로퍼티에 메서드를 추가하지 않아도 기본적으로 프로토타입 메서드
- 인스턴스는 프로토타입 체인의 일원이.. 된다... => 프로토타입 기반의 객체 생성 매커니즘

### 정적 메서드

- 정적 메서드는 인스턴스를 생성하지 않아도 호출할 수 있는 메서드
- 생성자 함수: 명시적으로 메서드 추가
- 클래스: 메서드에 static 키워드를 붙임 // 클래스에 바인딩된 메서드가 된다
- 클래스는 클래스 정의가 평가되는 시점에 함수 객체가 됨 (생성 과정x)

### 정적 메서드 and 프로토타입 메서드

- 프로토타입 체인이 다름
- 정적 메서드(클래스로 호출), 프로토타입 메서드(인스턴스로 호출)
- 프로토타입 메서드는 인스턴스 프로퍼티를 참조할 수 있다

### 마치 표준 빌트인 객체의 정적 메서드

- 클래스 또는 생성자 함수를 네임스페이스 namespace로 사용하여 정적 메서드를 모음.
- 충돌 가능성을 줄이고, 관련 함수들을 구조화할 수 있음

### 클래스에서 정의한 메서드 특징s

- function 키워드를 생략한 메서드 축약 표현
- 콤마 x (객체 리터럴과는 다름)
- 암묵적으로 strict mode임
- [[Enumerable]] 값이 false
- 내부 메서드 [[Construct]]를 갖지 않는 non-constructor

### 클래스의 인스턴스 생성 과정

> 1.  인스턴스 생성과 this 바인딩
> 2.  인스턴스 초기화
> 3.  인스턴스 반환

#### 1. 인스턴스 생성, this 바인딩

- new 연산자 + 클래스 호출, constructor 내부 코드가 실행되기 앞서 암묵적으로 빈 객체가 생성된다.(인스턴스)
- 인스턴스의 프로토타입으로, 클래스의 prototype 프로퍼티가 가리키는 객체 설정
- 암묵적으로 생성된 빈 객체 인스턴스는 this에 바인딩 된다.
- constructor 내부의 this는 클래스가 생성한 인스턴스를 가리킴

#### 2. 인스턴스 초기화

- constructor 내부 코드 실행, this에 바인딩되어 있는 인스턴스 초기화
- 프로퍼티를 추가, constructor가 인수로 전달 받은 초기값으로 프로퍼티 값 초기화

#### 3. 인스턴스 반환

- 클래스의 모든 처리가 끝나면, 완성된 인스턴스가 바인딩된 this => 반환
