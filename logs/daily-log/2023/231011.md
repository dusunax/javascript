# 📝메모\_231011

## 🔎 현재 학습 플랜

- 11시 10분~12시

| 순서 | 일정 | 내용         | 관련 서적/강의              |
| ---- | ---- | ------------ | --------------------------- |
| 1    | 12장 | JS 개념 공부 | 모던 자바스크립트 Deep Dive |

## 📌 JS: 메모, 12장

## 함수

### 함수란?

- 일련의 과정을 문으로 구현하고, 코드 블록으로 감싸서 하나의 실행 단위로 정의
- 입력받는 변수를 매개변수, 입력을 인수, 출력을 반환값이라 한다.

### 함수 호이스팅

- 선언문으로 정의한 함수는 선언문 이전에 호출
- 표현식으로 정의한 함수는 호출x
  - 함수의 생성 시점이 다르기 때문
  - 변수 할당문의 값이 런타임에 평가되므로, 할당문이 실행되는 시점에 함수 객체로 평가된다. 따라서 함수 호이스팅이 아니라 변수 호이스팅이 발생한다.
  - undefined으로 평가된다

### 함수 정의

- 함수를 호출하기 이전, 인수를 전달받을 매개변수와 실행할 문 + 반환할 값을 지정
  - 정의된 함수 => 자바스크립트 엔진에 의해 평가되어 함수 객체가 된다.

### 함수 정의 방식

1. 함수 선언문

- 함수 이름을 생략할 수 없다.
- 표현식이 아닌 문이다(return undefined)
- {}는 블록문이거나 함수 리터럴 표현식인 중의적인 표현
  - 암묵적으로 식별자를 생성 (함수 객체를 가리킴)
  - 식별자로 호출

2. 함수 표현식

- 👉 일급 객체: 값의 성질을 갖는 객체 ex) 자바스크립트의 함수
  - 함수를 값처럼 자유롭게 사용할 수 있다.
  - => 변수에 할당할 수 있다. // 함수 표현식
  - 함수 표현식: 변수가 식별자. 함수 이름을 생략하지 않을 시, 함수 이름은 함수 내에서만 유효한 식별자

3. Function 생성자 함수
   ```
   var add = new Function('x', 'y', 'return x + y')
   ```

- 적절하지 않음: 클로저를 생성하지 않음

4. [ES6] 화살표 함수
   ```
   var add = (x, y) => x + y
   ```

- 표현과 내부 동작 간략화
- prototype 프로퍼티가 없으며, arguments 객체 상성하지 않음

### 함수 호이스팅

- 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다름
  - 모든 선언문: 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행, 고로 함수 객체가 먼저 생성됨
- 자바스크립트 엔진이 함수명을 식별자로 암묵적으로 생성하고 생성된 함수 객체를 할당
- 호이스팅 차이: 초기화 다름
  - var 변수 선언문은 undefined로 초기화
  - 함수 선언문은 함수 객체로 초기화
- 함수 표현식은 변수에 할당되는 값이 함수 리터럴인 문. // 변수 선언문과 변수 할당을 축약한 것도 같이 동작
  - 변수 할당문의 값은 할당문이 실행되는 시점, 즉 런타임에 평가됨
  - 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가 => 함수 객체가 됨
- 함수 "표현식"으로 함수를 정의하면 함수 호이스팅이 아닌 변수 호이스팅이 발생한다.
- 함수를 호출하기 전에 함수를 선언해야 한다는 규칙 때문에 표현식 권장 => `<JavaScript: The Good Parts> 저자 + JSON 창안자 더글라스 크락포드`

### 함수 호출

- 식별자 + 함수 호출 연산자(소괄호지롱)
- 함수 호출 연산자
  - 0개 이상의 인수를 쉼포로 구분하여 나열
- 함수를 호출하면 실행 흐름을 중단하고, 함수로 실행 흐름을 옮김
  - 매개변수에 인수가 순서대로 할당되고, 함수 몸체의 문들 실행 시작

### 매개변수와 인수

- 인수의 개수와 타입은? 제한이 없다~
- 매개변수는? 함수 몸체 내부에서 변수와 동일하게 취급한다~
  - undefined로 초기화되고, 인수가 순서대로 할당됨
  - 스코프는 함수 내부다~
- 인수 갯수
  - 부족하면? undefined 초기화된 상태 그대로
  - 넘치면? 암묵적으로 arguments 객체의 프로퍼티에 보관
- arguments 객체
  - 매개변수 개수를 확정할 수 없는 가변인자 함수를 구현할 때 유용함
- 인수 확인
  1. 타입 체크 ex) typeof ...
  2. 단축 평가 ex) a = a || 0;
  3. 매개변수 기본값 ex) add(a=0)
- 매개변수: 순서에 의미 있음. 개수가 많으면 여러 가지 일을 한다는 증거
  - 이상적인 함수: 하나의 함수가 한 가지 일만 해야 하며 가급적 작게 만들기 // from 클린 코드
- 여러 개의 인수를 넘길 때, 객체를 인수로 사용할 수 있음
  - 객체를 인수로 사용할 시
    - 프로퍼티 키만 정확하면 순서를 신경쓰지 않아도 됨
    - 인수의 의미를 설명하는 프로퍼티 키 사용하여 가독성 업
    - 👉 함수 외부에서 전달한 객체를 내부에서 변경하면, 외부 객체가 변경되는 부수 효과가 발생 (참조에 의한 전달)

### 반환문

- 함수 호출 표현식은 return 평가 결과 // 즉, 반환값으로 평가된다.
- return은 함수 몸체 내부에서만 사용할 수 있다. // 밖에서 referance error, 근데 nodeJS에서는 아님
  (자투리: NodeJS는 모듈 시스템에 의해 파일별로 독립적인 파일 스코프를 가짐)

### 참조에 의한 전달, 그리고 외부 상태 변경 side effect

- 원시 값은 값에 의한 전달 pass by value / 객체는 참조에 의한 전달 pass by reference
- 호출 방식을 값에 의한 호출 call by value, 참조에 의한 호출 call by reference 로 구별해 부르는 경우도 있음

```tsx
function chageVal(primitive, obj) {
  primitive += 100;
  obj.name = "Kim";
}

// 외부 상태
var num = 100;
var person = { name: "Lee" };

changeVal(num, person); // 원시값: 값 자체 복사, 객체값: 참조 값 복사

console.log(num); // 100
console.log(person); // {name: "Kim"}
```

- 원시 값은 불변값이므로 값이 복사되어 할당되었고, 매개변수의 값과 서로 상관 없음
- 객체 값은 변경 가능한 값이므로, 재할당 없이 직접 할당된 객체를 변경했음
- 객체 값을 방어적 복사를 통해 새로운 객체로 생성, 재할당하여 교체해 side effect를 없앨 수 있음
  - 순수 함수: 외부 상태 변경x
- 함수형 프로그래밍
  - 📌 순수 함수를 통해 부수 효과를 억제하며 오류를 피하고, 안정성을 높이려는 프로그래밍 패러다임

### 즉시 실행 함수 IIFE, Immediately Invoked Function Expression

- 단 한 번 호출, 다시 호출할 수 없고, 익명함수가 일반적
- 묶는 이유? 함수 리터럴을 평가하여 함수 객체를 생성하기 위해서
  - 함수 호출 연산자로 바로 실행

### 재귀 함수

- 재귀재귀
- 표현식 // 함수 내부에서는 함수 이름을 사용해 호출할 수 있다. 외부에서는 함수를 가르키는 식별자를 써야함
- 탈출 조건! 없다면 스택 오퍼플로 stack overflow
  - 주의: 반복문보다 직관적으로 이해하기 쉬울 때 한정적으로 사용

### 중첩 함수

- 함수 내에 정의된 함수 nested function, inner function <=> outer function
- 중첩 함수는, 자신을 포함하는 외부 함수를 돕는 헬퍼 함수 helper functions
